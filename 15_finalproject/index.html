<!DOCTYPE html>
<html lang="en">
<head>
  <title>PS70: Intro to Digital Fabrication</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
  <style>
    /* Remove the navbar's default margin-bottom and rounded borders */ 
    .navbar {
      margin-bottom: 0;
      border-radius: 0;
    }
    
    /* Add a gray background color and some padding to the footer */
    footer {
      background-color: #f2f2f2;
      padding: 25px;
    }
  </style>
</head>

<body>

<nav class="navbar navbar-inverse">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>                        
      </button>
      <a class="navbar-brand" href="#">PS70: Intro to Digital Fabrication</a>
    </div>
    <div class="collapse navbar-collapse" id="myNavbar">
      <ul class="nav navbar-nav">
        <li><a class="nav-link" href="/ps70/index.html">Home</a></li>
        <li><a class="nav-link" href="/ps70/about.html">About</a></li>
      </ul>
    </div>
  </div>
</nav>

<div class="container-fluid bg-3 text-center">    
  <h3>FINAL PROJECT</h3><br>
</div>


<xmp style="display:none;">
<br> 


### Final Project Idea

Keeping in line with my interests outlined in <a href="nchoi22.github.io/ps70/01_intro/index.html">Week 1</a>, I decided to create a PID control system for my final project. "PID" stands for proportional, integral, and derivative, respectively, and is a very common and powerful way to design and tune effective control systems. I decided to build a relatively simple, yet challenging control system: balancing a ping pong ball on the middle of a beam. A sample setup is shown below:

<div class="container-fluid bg-3 text-center">    
  <div class="row">
    <div class="col-sm-3">
      <img src="/ps70/sample_beam.png" class="img-responsive" style="width:100%" alt="Image"></a>
    </div>
  </div>
</div><br>

As we can see, a ball can freely roll along a beam with one degree of freedom: its angle. Though the setup is relatively simple, this type of control system is analagous to much more complicated ones, such as control thrusters to maintain the orientation of a rocket.

Initially, I also wanted to gamify this setup, allowing a user to control the angle of the beam manually using a remote control. This controller would have button and/or tilt control, using buttons and IMU's, respectively, to change the angle of the beam. However, just creating the automatic controller itself proved to be a big challenge, an this became the focus of the project without the gamification.


### Final Demo Video

Before getting into the nitty gritty of how this project came together, below is a video showing the current functionality of the PID controller. After many iterations, though we don't have a perfect controller, the ball does stay close to the center of the beam!

(If the video doesn't play, please navigate to this <a href="https://www.youtube.com/watch?v=3Fz6Z_iDU54&ab_channel=NoaChoi">Youtube Link</a>.)

<iframe width="1019" height="573" src="https://www.youtube.com/embed/3Fz6Z_iDU54&ab_channel=NoaChoi" frameborder="0" 
allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen> </iframe> 

### Build Process and Details

In this section, I will outline in detail various steps throughout the development of this project.

#### The Remote

Initially, I was planning to design a remote control for the "game" version of the controller. Thus, I wanted to implement radio communication between two ESP 32 S2 microcontrollers. Initially, I tried achieving this using LoRa RMF95W radio modules, but then pivoted to using the <a href="https://nathanmelenbrink.github.io/ps70/09_networking/index.html">ESP_NOW protocol</a> for direct communication between two ESP microcontrollers. Of course, since the game part of the project was abandoned, this portion was not completed. However, progress on this front can be found on the <a href="nchoi22.github.io/ps70/09_iot/index.html">IoT and Radio</a> page.

#### The Beam Machine (Attempt #1)

I first had to come up with a design for the actual beam. I had several design considerations in creating my setup: How long should the beam be? What kind of motor should I use to control the angle of the beam? How will the beam and motor be coupled? What sensor should I use to provide input data to my system?

My initial designs were inspired by examples found online of previous theses and projects done on similar ideas. Mostly due to constraints on materials in the lab, I decided to use four aluminum rods of ~9.5mm diameter and ~1 foot length to create a railing to act as a beam. Thus, I also needed to design end caps that would hold the rods in place from either end of the beam. A CAD model of this is shown below:

[INSERT IMAGE]

I decided to use the ultrasonic sensor HC-SR04, attached to one end of the beam. That way, I could use the ball's position, read from this sensor, as the INPUT to the control system, with the beam's angle controlled by a motor as the OUTPUT of the system.

Next, I decided to use the NEMA17 stepper motor as my actuator to control the beam angle. Although many examples found online used servo motors, I opted for the stepper motor as it has higher holding torque than servo motors, which was the motor of choice for many examples online. The higher torque was important as my beam, being made of aluminum, was not light. I also chose to have the motor attach to the beam at the beam's center. I then had to decide how the motor would become coupled, or attached, to the beam. Luckily, Nathan and the PS70 Lab had a pan-tilt machine, with open-source 3D printable parts, readily available for me to draw inspiration from. This pan-tilt machine is shown below:

<div class="container-fluid bg-3 text-center">    
  <div class="row">
    <div class="col-sm-3">
      <img src="/ps70/pantilt.png" class="img-responsive" style="width:100%" alt="Image"></a>
    </div>
  </div>
</div><br>

As you can see, this design provides mounts (green) in the front and back of the NEMA17 that can allow the motor to be bolted to a stable surface, and also includes an arm (black) that contains a rotary bearing. The NEMA17 is connected to a 20 tooth timing pulley, which is in turn connected to a 60 tooth timing pulley (orange) via a 200mm long timing belt. The 60 tooth timing pulley (orange) is then connected to a holder. With all of this setup available, I was free to use these open source designs to couple my motor and beam together. All I needed to design was the beam holder.

<div class="container-fluid bg-3 text-center">    
  <div class="row">
    <div class="col-sm-3">
      <img src="/ps70/iter1_1.png" class="img-responsive" style="width:100%" alt="Image"></a>
    </div>
    <div class="col-sm-3">
      <img src="/ps70/iter1_2.png" class="img-responsive" style="width:100%" alt="Image"></a>
    </div>
    <div class="col-sm-3">
      <img src="/ps70/iter1_3.png" class="img-responsive" style="width:100%" alt="Image"></a>
    </div>
  </div>
</div><br>

Above are images of the first iteration of the beam design, displaying what the end caps and beam holder look like, and the overall setup of the machine. It's clear in the first image that the beam holder needed a redesign - it didn't allow the ball to pass through the middle. It was also apparent that the end cap needed to be designed to allow for the ultrasonic sensor to be stable. 

A redesign in the parts involved multiple iterations of CADing and 3D prints, resulting in a beam with wider top rods to allow room for the ball in the center of the beam (and to fit the ultrasonic sensor in between the two top rods), a new beam holder (imaged below), and a new end cap that fits the emitter and receiver of the ultrasonic sensor snugly for stability. 

<div class="container-fluid bg-3 text-center">    
  <div class="row">
    <div class="col-sm-3">
      <img src="/ps70/beam_holder_final.png" class="img-responsive" style="width:100%" alt="Image"></a>
    </div>
    <div class="col-sm-3">
      <img src="/ps70/setup2.png" class="img-responsive" style="width:100%" alt="Image"></a>
    </div>
  </div>
</div><br>

The image on the right shows the final hardware setup at this stage in the project. The ultrasonic sensor is now fit within the end cap, and the motor rig is mounted to a piece of wood, with added weights for stability. Due to the design of the motor holds, it was easy to thread M3 screwholes into the wood and mount the rig into the wood.

Getting to this point alone took a lot of time and iterations. Concurrently, I was setting up the circuitry and code that would drive the controller, testing out each component individually before putting them together in an Arduino sketch. The circuit contains: ESP32S2 microcontroller, NEMA17 Stepper Motor, A4988 Motor Driver, ultrasonic sensor HC-SR04, and a 12V wall plug power source (for the stepper motor).

After the hardware was complete, I added PID control software to the Arduino sketch. The PID control software can be found below in the "Code" section (note: the code found there is the final code, not the code used during this phase of the project. The code from this phase is not included because it is mostly very similar, except for what sensor is being used). Upon testing, the results were not great, as can be seen below:

[INSERT VIDEO]

Clearly, the controller was not working as intended. A huge problem I discovered during testing was that the ultrasonic sensor was very inaccurate only in the center portion of the beam. This was because of how the ultrasonic sensor works and the geometry of the ping pong ball. The sensor pings whatever object is in front of it with a 40kHz sound wave, and calculates the distance to the object based on how long it takes for the signal to get back to the sensor's receiver. However, at a certain point, because of how far apart the receiver and emitter are and because the ping pong ball is a sphere, the emitted signal will scatter off of the ball and not bounce directly back to the receiver, giving faulty results. 

The imprecision of the sensor severely limited the ability to control the ball's position. However, due to the fact that the sensor was accurate between the sensor and the center of the beam, I was able to sort of control the ball within this section of the beam:

[INSERT VIDEO]

#### The Beam Machine (Attempt 2)

Due to the sensor's limitations, I decided to try this out with a different sensor. Per Nathan's recommendation, I went ahead and ordered the VL53L1X Time-of-Flight (ToF) sensor (imaged below).

[INSERT IMAGE]

This sensor uses the time it takes for an infrared laser to bounce off of an object to measure the object's distance, and the emitter and receiver are very close together. In addition, this sensor has a proximity range of ~3cm - 4m. Thus, theoretically, this sensor should work very well with this system.

Upon receiving the sensor, I redesigned the end cap to fit the sensor in snugly for stability. I very slightly overcut the opening, but a little bit of masking tape on the sensor did the trick:

<div class="container-fluid bg-3 text-center">    
  <div class="row">
    <div class="col-sm-3">
      <img src="/ps70/endcap_final.png" class="img-responsive" style="width:100%" alt="Image"></a>
    </div>
    <div class="col-sm-3">
      <img src="/ps70/sensor_fit.png" class="img-responsive" style="width:100%" alt="Image"></a>
    </div>
  </div>
</div><br>




### Electronics


### Code


### Materials


### Downloadable Files

1. <a download="/ps70/beam_holder.stl">Beam Holder STL File</a><br>
2. 



</xmp>
</body>

<script src="../strapdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" ></script>

</html>